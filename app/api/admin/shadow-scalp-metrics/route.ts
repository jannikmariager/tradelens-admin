import { createClient } from '@supabase/supabase-js';\nimport { NextRequest, NextResponse } from 'next/server';\n\nconst supabase = createClient(\n  process.env.NEXT_PUBLIC_SUPABASE_URL || '',\n  process.env.SUPABASE_SERVICE_ROLE_KEY || ''\n);\n\nexport async function GET(request: NextRequest) {\n  try {\n    // Fetch SCALP portfolio\n    const { data: portfolioData, error: portfolioError } = await supabase\n      .from('engine_portfolios')\n      .select('*')\n      .eq('engine_key', 'SCALP')\n      .eq('engine_version', 'SCALP_V1_MICROEDGE')\n      .eq('run_mode', 'SHADOW')\n      .maybeSingle();\n\n    if (portfolioError) {\n      console.error('[shadow-scalp-metrics] Portfolio error:', portfolioError);\n      throw new Error('Failed to fetch portfolio');\n    }\n\n    // Fetch all SCALP trades (from engine_trades table)\n    const { data: trades, error: tradesError } = await supabase\n      .from('engine_trades')\n      .select('*')\n      .eq('engine_key', 'SCALP')\n      .eq('engine_version', 'SCALP_V1_MICROEDGE')\n      .eq('run_mode', 'SHADOW')\n      .order('opened_at', { ascending: false })\n      .limit(500);\n\n    if (tradesError) {\n      console.error('[shadow-scalp-metrics] Trades error:', tradesError);\n      throw new Error('Failed to fetch trades');\n    }\n\n    // Fetch open positions\n    const { data: openPositions, error: posError } = await supabase\n      .from('engine_positions')\n      .select('*')\n      .eq('engine_key', 'SCALP')\n      .eq('engine_version', 'SCALP_V1_MICROEDGE')\n      .eq('run_mode', 'SHADOW')\n      .eq('status', 'OPEN');\n\n    if (posError) {\n      console.error('[shadow-scalp-metrics] Position error:', posError);\n      throw new Error('Failed to fetch positions');\n    }\n\n    // Fetch SCALP config for max_positions\n    const { data: configData } = await supabase\n      .from('scalp_engine_config')\n      .select('max_concurrent_positions')\n      .eq('is_enabled', true)\n      .maybeSingle();\n\n    const maxPositions = configData?.max_concurrent_positions || 4;\n    const openCount = openPositions?.length || 0;\n\n    // Calculate metrics\n    const portfolio = portfolioData as any;\n    const allTrades = (trades || []) as any[];\n    const closedTrades = allTrades.filter(t => !t.opened_at || new Date(t.closed_at) <= new Date());\n\n    const totalPnL = closedTrades.reduce((sum, t) => sum + (t.realized_pnl || 0), 0);\n    const winCount = closedTrades.filter(t => (t.realized_pnl || 0) > 0).length;\n    const lossCount = closedTrades.filter(t => (t.realized_pnl || 0) < 0).length;\n    const winRate = closedTrades.length > 0\n      ? (winCount / closedTrades.length) * 100\n      : 0;\n\n    const totalR = closedTrades.reduce((sum, t) => sum + (t.realized_r || 0), 0);\n    const avgTradeR = closedTrades.length > 0 ? totalR / closedTrades.length : 0;\n\n    const metrics = {\n      total_trades: closedTrades.length,\n      trades_won: winCount,\n      trades_lost: lossCount,\n      win_rate_pct: parseFloat(winRate.toFixed(2)),\n      total_pnl: parseFloat(totalPnL.toFixed(2)),\n      avg_trade_r: parseFloat(avgTradeR.toFixed(4)),\n      open_positions: openCount,\n      max_positions: maxPositions,\n      current_equity: portfolio?.equity || 100000,\n      starting_equity: portfolio?.starting_equity || 100000,\n    };\n\n    // Format trades for display\n    const formattedTrades = allTrades.map(t => ({\n      id: t.id,\n      ticker: t.ticker,\n      entry_price: parseFloat(t.entry_price),\n      exit_price: t.exit_price ? parseFloat(t.exit_price) : null,\n      entry_time: t.opened_at,\n      exit_time: t.closed_at,\n      side: t.side,\n      pnl_dollars: t.realized_pnl ? parseFloat(t.realized_pnl.toFixed(2)) : null,\n      pnl_pct: t.realized_pnl && t.entry_price\n        ? parseFloat(((t.realized_pnl / (t.entry_price * (t.meta?.qty || 1))) * 100).toFixed(2))\n        : null,\n      pnl_r: t.realized_r ? parseFloat(t.realized_r.toFixed(2)) : null,\n      exit_reason: t.meta?.exit_reason || null,\n      status: new Date(t.closed_at) <= new Date() ? 'CLOSED' : 'OPEN',\n      entry_qty: t.meta?.qty || 1,\n      entry_risk_pct: 0.15, // Default from config, could fetch from scalp_execution_log\n    }));\n\n    // Also get details from scalp_execution_log if available\n    const { data: executionLogs } = await supabase\n      .from('scalp_execution_log')\n      .select('*')\n      .order('entry_time', { ascending: false })\n      .limit(500);\n\n    // Merge with execution logs for more details\n    const enrichedTrades = formattedTrades.map(trade => {\n      const log = executionLogs?.find(l => l.signal_id === trade.id || l.ticker === trade.ticker);\n      return {\n        ...trade,\n        entry_risk_pct: log?.entry_risk_pct || trade.entry_risk_pct,\n        entry_qty: log?.entry_qty || trade.entry_qty,\n      };\n    });\n\n    return NextResponse.json(\n      {\n        status: 'ok',\n        metrics,\n        trades: enrichedTrades,\n      },\n      { status: 200 }\n    );\n  } catch (error) {\n    console.error('[shadow-scalp-metrics] Error:', error);\n    return NextResponse.json(\n      {\n        status: 'error',\n        error: error instanceof Error ? error.message : 'Unknown error',\n      },\n      { status: 500 }\n    );\n  }\n}\n"}}